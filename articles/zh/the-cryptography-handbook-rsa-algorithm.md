```markdown
---
title: "密码学手册：探索 RSA PKCSv1.5、OAEP 和 PSS"
date: 2025-07-17T02:05:54.139Z
author: Hamdaan Ali
authorURL: https://www.freecodecamp.org/news/author/hamdaan/
originalURL: https://www.freecodecamp.org/news/the-cryptography-handbook-rsa-algorithm/
posteditor: ""
proofreader: ""
---

RSA 算法于 1978 年在开创性的论文《获取数字签名和公钥密码系统的方法》中提出。几十年来，随着 RSA 成为安全通信中不可或缺的一部分，各种漏洞和攻击也随之出现，这强调了正确理解和实现 RSA 的重要性。

<!-- more -->

本手册将帮助您理解 RSA 算法的内部工作原理，它们如何随着时间的推移而演变，以及在各种 RFC 中定义的方案。通过这些知识，您可以根据自己的业务需求对最合适的 RSA 方案做出明智的选择。

在本手册中，我们将首先探索 RSA 算法的基础原理。通过研究其数学基础和历史演变，您将深入了解多年来出现的各种攻击。

这一叙述如同一段进化之旅：从最初的简单（教科书）RSA 实现，到发现漏洞，再到开发有效的对策，以及在遇到新挑战时的进一步改进。这个过程揭示了 RSA 如何随着时间的发展而改变，也展示了现代密码库如何集成这些进步，以在当今应用中实现安全实现。

您还可以在这里观看相关视频：

<iframe width="560" height="315" src="https://www.youtube.com/embed/jpcLbsuHWbU" style="aspect-ratio: 16 / 9; width: 100%; height: auto;" title="YouTube 视频播放器" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="" loading="lazy"></iframe>

## 目录

-   [先决条件][1]
    
-   [Alice-Bob 范式][2]
    
-   [RSA 密码系统的诞生][3]
    
    -   [素数与合成模量][4]
        
    -   [欧拉函数][5]
        
    -   [密钥计算][6]
        
-   [RSA 操作][7]
    
    -   [加密][8]
        
    -   [解密][9]
        
    -   [数字签名][10]
        
-   [RSA 中的欧拉函数问题][11]
    
-   [Carmichael 函数][12]
    
    -   [Carmichael 函数的数学意义][13]
        
    -   [现代实现中的 Carmichael 函数][14]
        
-   [原始 RSA 的问题][15]
    
-   [利用教科书 RSA 的确定性和可操控性][16]
    
    -   [密钥生成（设置）][17]
        
    -   [加密过程][18]
        
    -   [确定性利用（密文猜测攻击）][19]
        
    -   [可操控性利用（密文操控攻击）][20]
        
-   [低指数攻击][21]
    
-   [Håstad 的广播攻击：低指数遇上多个接收者][22]
    
-   [RSA 填充方案简介][23]
    
-   [公钥密码学标准 (PKCS#1 v1.5)][24]
    
    -   [PKCS#1 v1.5 背后的数学原理][25]
-   [Bleichenbacher 攻击][26]
    
-   [最优非对称加密填充 (OAEP)][27]
    
    -   [OAEP 背后的数学原理][28]
-   [为什么 SHA-1 或 MD5 在 RSA-OAEP 中是安全的][29]
    
    -   [标签哈希][30]
        
    -   [掩码生成函数 (MGF1)][31]
        
-   [加密库中的采用 (PKCS#1 v1.5 vs OAEP)][32]
    
-   [增强数字签名：向 PSS 的过渡][33]
    
    -   [早期 RSA 签名方案的问题][34]
        
    -   [概率签名方案 (PSS) 的诞生][35]
        
    -   [PSS 背后的数学原理][36]
        
-   [前方的道路：评估 RSA 的长期可行性][37]
    
-   [参考文献][38]
    

## 先决条件

1.  **线性代数：** 线性代数和模算术的基础知识将帮助您理解手册的某些部分，尽管这并不是绝对必要的。本手册提供了数学表达式及其基础概念的全面解释。

为了在本手册的背景下对中国剩余定理 (CRT) 进行简洁且相关的入门介绍，您可能会发现这个资源有所帮助：[CRT, RSA, 和低指数攻击 | YouTube][39]。

2.  **耐心（以及冒险精神）：** RFC 有时可能会显得枯燥，研究论文初看上去也可能令人望而生畏。本手册旨在使标准密码学概念对每个人都容易理解，以清晰和直观的方式引导您一步步学习。每个概念都通过明确的步骤和示例强化，不仅保证彻底理解，而且使您熟悉广泛使用的标准符号。所以请慢慢来，深呼吸，尽情享受这段旅程。
```

## **Alice-Bob 范式**

在本手册中，你将遇到大量采用 Alice-Bob 范式的序列图和数学证明。

Alice-Bob 范式是密码学中的一个常见约定，其中通常使用名为 Alice 和 Bob 的两个通用实体来说明各种场景、协议或密码学原理。

![Alice Bob 范式](https://cdn.hashnode.com/res/hashnode/image/upload/v1742677993632/c9312974-4cb9-4496-8b23-b6d0d61c0a45.png)

这些角色代表进行通信的两个方，其中 Alice 通常代表发送者或发起者，Bob 代表接收者或响应者。

我们经常引入 Eve 作为第三方，象征窃听者或潜在攻击者，增加了一个安全风险因素，并演示外部实体可能尝试拦截或操控通信的场景。

## RSA 密码系统的诞生

1978 年见证了一个密码学新时代的诞生，即 RSA 密码系统的引入，该系统以其发明者（Rivest、Shamir 和 Adleman）的名字命名。

这种发展在论文 “A Method for Obtaining Digital Signatures and Public-Key Cryptosystems” 中被介绍，提供了一种安全的数字通信方法，并为现代公钥密码学奠定了基础。

RSA 的核心是基础数论——特别是质数的性质和模运算。首先让我们理解这些关键概念如何构成其数学基础。

### 质数与复合模数

该算法首先选择两个大质数，记为 _p_ 和 _q_。它们的乘积 (\\(n = p \\times q\\)) 构成了公钥和私钥的模数。

RSA 的安全性在很大程度上依赖于这样一个事实：虽然这些质数的乘积计算起来很简单，但对结果的大复合数 _n_ 进行因数分解对于足够大的质数来说是不可行的。

此时，重要的是要注意，p 和 q 必须是大质数才能确保 RSA 的安全性。幸运的是，现代库通过使用成熟的质数生成算法自动处理了这一点。因此，您可以专注于应用程序的更高层次方面，而无需管理质数选择的低级细节。

例如，让我们看看 OpenSSL 的 RSA 密钥生成例程，它执行若干检查以确保生成的模数 \\(n = p \\times q \\) 满足所需的位长度要求：

下面的代码段通过将生成的质数的乘积（存储在 `r1` 中）右移 `bitse - 4` 位来隔离最高的 4 位，然后检查以确保模数满足所需的大小标准。

```
if (!BN_rshift(r2, r1, bitse - 4))
    goto err;
bitst = BN_get_word(r2);
```

提取出的位 (`bitst`) 然后与预定义范围（从 `0x9` 到 `0xF`）比较。此范围确保模数的最高有效字节既不太小也不太大。

```
if (bitst < 0x9 || bitst > 0xF) {
    bitse -= bitsr[i];
```

如果明显位不在所需范围内，则调整位长度并重试质数生成过程。如果重试次数超过设定限制，则重新启动整个过程。

```
if (!BN_GENCB_call(cb, 2, n++))
    goto err;
if (primes > 4) {
    if (bitst < 0x9)
        adj++;
    else
        adj--;
} else if (retries == 4) {
    i = -1;
    bitse = 0;
    sk_BIGNUM_pop_free(factors, BN_clear_free);
    factors = sk_BIGNUM_new_null();
    if (factors == NULL)
        goto err;
    continue;
}
retries++;
goto redo;
```

为了确保这些数字一定是质数，这些库使用了一系列概率测试，包括 Rabin-Miler 素数检测，以及筛法来快速消除非素数候选。

### 欧拉函数

对于一个质数乘积构成的数字 _n_，欧拉函数表示为：

$$\\varphi(n) = (p-1)(q-1)$$

这个函数计算出小于 \\(n\\) 且与 \\(n\\) 互质的整数个数。欧拉定理指出，对于与 _n_ 互质的任何整数 _a_，有\\( a^{\\varphi(n)} \\equiv 1 \\pmod{n}\\)，这在证明 RSA 操作可逆性中起到了核心作用。

但现在大多数现代 RSA 密码系统使用 Carmichael 函数代替欧拉函数。我们将在接下来的几个部分中研究这一变化的理由。

### 密钥的计算

现在，我们选择一个整数 \\(e\\)，使得 \\(1 < e < \\varphi(n)\\) 且 \\(\\gcd(e, \\varphi(n)) = 1\\)。这个 \\(e\\) 就是你在使用 RSA 函数时看到的公钥指数参数。

完成此步骤后，现在让我们确定 \\(d\\) 作为 \\(e \\, \\, modulo \\, \\varphi(n)\\) 的模数乘法逆元。换句话说，\\(d\\) 的计算满足：

$$e \\times d \\equiv 1 \\pmod{\\varphi(n)}$$

这一步是确保解密是加密反操作的数学支撑。

在 1978 年的论文中，作者明确提供了这些公式和步骤。他们展示了如果你用 \\(c = m^e \\mod n\\) 对信息 m 加密，然后 用 \\(m = c^d \\mod n \\) 解密，原始信息可以被恢复——这要归功于模指数运算和欧拉定理的性质。这个数学框架当时很新颖，并立即为密码学的新纪元奠定了起点。

现在数学基础已经奠定，RSA算法可以视为一组三个核心操作：加密、解密和签名。在本手册的后续章节中，我们将批判性地分析这些操作，并了解每个操作中的若干陷阱。之后，我们将检查这些问题是如何被新方案的诞生所避免的，每个方案都解决了在此过程中发现的新问题。

### 加密

由于公钥\\((n, e)\\)对所有人开放，任何用户可以通过以下公式加密消息\\(m\\)（其中\\(m\\)首先被编码为范围在\\(0 \\leq m < n\\)之间的整数）：

$$c = m^e \\mod n$$

其中，c是密文。因为该操作基于模幂运算，即使知道m，如果不知道d，想从c中恢复m是计算上很困难的。

### 解密

拥有私钥\\(d\\)的指定接收者，通过计算下方公式来解密密文\\(c\\)：

$$m = c^d \\bmod n$$

利用关系式(\\(e \\times d \\equiv 1 \\pmod{\\varphi(n)}\\))以及欧拉定理的性质，上述操作精确地逆转了加密步骤，从而恢复原始消息\\(m\\)。

这确保了只有私钥的持有者才能读取加密信息。这是RSA用于安全通信的基础。

下方的时序图总结了我们迄今为止的讨论：

![时序图：教材RSA加密](https://cdn.hashnode.com/res/hashnode/image/upload/v1742754978876/9b007639-8595-4d11-93ff-355820cb98c7.png)

### 数字签名

数字签名满足不同的安全目标：真实性和完整性，而非机密性。当加密和解密使用公钥进行“锁定”和私钥进行“解锁”时，数字签名恰好相反。

#### 1. 签名

消息的作者使用他们的私钥\\(d\\)来计算消息\\(m\\)的签名\\(s\\)，引导公式如下：

$$s = m^d \\bmod n$$

之后可以通过对应的公钥进行验证。这里的目的是不是要恢复一个秘密消息，而是为了创建一个认证证明。

#### 2. 验证：

任何人都可以借助公钥\\((n, e)\\)来验证签名s是否确实属于消息\\(m\\)，通过计算：

$$m \\equiv s^e \\bmod n$$

如果这个等式成立，它可以确认两个关键点：消息没有被篡改（即完整性），签名必然是使用私钥d生成的（即真实性）。  
只要\\(d\\)保持秘密，只有合法的签署者才能生成有效的签名。请查看下方的时序图以了解完整过程。

![时序图：教材RSA签名](https://cdn.hashnode.com/res/hashnode/image/upload/v1742755268516/6dea4239-f214-42c4-96c7-5fc55c7249d9.png)

## RSA中的欧拉函数问题

虽然使用欧拉函数在理论上效果很不错，但方案的实现者意识到其实际的缺陷。简单说，主要的问题在于欧拉函数可能导致私钥指数\\(d\\)比必要的大。

要完全理解这一点，我们先退一步来了解私钥指数\\(d\\)的大小为何在RSA中重要。

RSA解密（或签名）涉及计算\\(m^d ~~mod ~n\\)，该计算通过模幂运算完成。指数运算算法（如平方-乘法算法）的时间复杂度随\\(d\\)中的位数增加而增长。较大的\\(d\\)意味着更多的乘积与平方运算，因而解密速度更慢。

在实际中，如果使用欧拉函数使\\(d\\)大约是所需的两倍，那么解密速度可能几乎减少一半，这种低效尤其在当\\(e\\)很小（如常用公钥指数3或65537）时显著。小的\\(e\\)在\\(φ(n)\\)下会导致非常大的\\(d\\)。

除了性能影响，拥有不必要大的\\(d\\)可能略微增加存储需求（密钥需要更多字节）。这也可能导致某些兼容性问题，这就是为什么FIPS 186-4 \[1\]和RFC 8017 \[2\]等标准和协议要求\\(d\\)保持在一定大小以下。在下一节我们会对此进行详细讨论。

为了应对这些问题，密码学家们利用Carmichael函数来生成RSA密钥。在我们深入Carmichael函数如何有助于我们的问题之前，我们先快速了解什么是Carmichael函数。

## Carmichael函数

Carmichael函数，由\\(λ(n)\\)表示，也称为缩减的欧拉函数或最小公倍指数，被定义为对于每一个与\\(n\\)互质的整数\\(a\\)，使\\( a^m ≡ 1 (mod n)\\)的最小正整数\\(m\\)。

简单来说，\\(λ(n)\\)是模\\(n\\)乘法群的指数（所有元素阶的最小公倍数）。对于RSA风格的模数（素数积），Carmichael函数通过以下公式进行指导：

$$\\lambda(n) = \\operatorname{lcm}(p-1,\\,q-1)$$

您现在可以更好地理解 Carmichael 函数，如果我们用以下方式来解释：\\(λ(n)\\) 是每个质数幂次整除 n 的 \\(λ(n)\\) 的最小公倍数。因此，对于一个质数 \\(p\\)，\\(λ(p) = φ(p) = p – 1\\)，而对于两个质数，我们取 \\(p-1 \\) 和 \\(q-1\\) 的 \\(lcm\\)。

### Carmichael 函数的数学意义

Carmichael 函数 \\(λ(n)\\) 是一个“更紧”的界限。这意味着 \\(λ(n)\\) 可以整除 \\(φ(n)\\)（因为有限群的指数总是可以被群的阶数整除，根据拉格朗日定理 \[3\]）

如果 \\(p\\) 和 \\(q\\) 都是奇数质数，则 \\(p–1\\) 和 \\(q–1 \\) 是偶数，因此它们的最小公倍数大约是 \\((p–1)(q–1)\\) 的一半。数学上：

$$λ(n) = \\dfrac{(p–1)(q–1)} {gcd(p–1, q–1)}$$

我们可以观察到这个 \\(λ(n)\\) 小于或等于 \\(φ(n)\\)，并且通常要小很多。这意味着 \\(λ(n)\\) 提供了 RSA 正确性所需的最小指数，而 \\(φ(n)\\) 可能是一个更大的数字，虽然也可以使用，但并不是必要的。

当您选择两个大的随机质数 \\(p\\) 和 \\(q\\) 时，您有：

$$\\varphi(n) = (p-1)(q-1) \\approx n,$$

因为对于大质数，减去的几个通常相对于 \\(p\\) 和 \\(q\\) 自身差别不大。

现在，因为 \\(p-1\\) 和 \\(q-1 \\) 都是偶数，所以它们各有一个因子 2。如果这是它们唯一的公因子（对于随机质数通常是这种情况），那么：

$$\\lambda(n) = \\mathrm{lcm}(p-1, q-1) \\approx \\frac{\\varphi(n)}{2}.$$

当您计算私有指数 \\(d\\) 作为 \\(e\\)（小数字）模 \\(\\varphi(n)\\) 的模反元素与模 \\(\\lambda(n)\\) 相比，前者中选择的 \\(d\\) 范围大约是后者的两倍。这意味着通常用模 \\(\\varphi(n)\\) 计算的 \\(d\\) 可能大约是用模 \\(\\lambda(n)\\) 计算的两倍大。较大的 \\(d\\) 意味着在解密（或签名）时模幂运算 \\(c^d \\mod n\\) 所需的时间略多。

直观上，使用 \\(λ(n)\\) 确保我们不会“超出”模运算回到 1 所需的指数。

较小的 \\(d\\) 使得每次 RSA 解密和签名操作更快。例如，如果 \\(λ(n)\\) 大约是 \\(φ(n)\\) 的一半，那么 \\(d\\) 将比其他情况下少一位，从而将幂运算工作量减少约 50%。这是一种免费的性能提升，因为我们没有改变安全假设或密钥大小 \\(n\\)，只是使用了数学上紧凑的指数值。RSA 算法的安全性没有因此被削弱，而 \\(d\\) 现在虽然不同但在功能上等效。

### Carmichael 函数在现代实现中的应用

对 RSA 的关键属性（\\(e·d ≡ 1 ~mod ~~λ(n)\\)）是必要且充分的，因为 Carmichael 定理保证了正确解密。因此，\\(d\\) 不需要额外满足模 \\(φ(n)\\) 的更强条件。

通过切换到计算 \\(d ~ mod ~~ λ(n)\\)（即 \\(d = e^{-1} ~mod ~~λ(n)\\)），我们直接获得了最小可用的私有指数。罗纳德·里维斯特（Ronald Rivest）在其 1999 年开创性论文中 \[4\] 指出，使用 \\( λ(n)\\) 而不是 \\(φ(n)\\) 求解 \\(d\\) 是稍微优选的，因为这样可以得到更小的 \\(d\\) 值。

随着时间推移，使用 \\( λ(n)\\) 在 RSA 中从一个学术建议发展为工业标准。今天的加密标准明确承认或要求使用 \\(λ(n)\\) 方法。

例如，官方 RSA 标准（PKCS #1 v2.2，RFC 8017 \[2\]）定义了基于 \\(λ(n)\\) 的 RSA 密钥生成。它指定私有指数 \\(d\\) 被选择，使得 \\(e·d ≡ 1 (mod λ(n))\\)（其中 \\(λ(n) = lcm(p–1, q–1)\\)）。换句话说，PKCS #1 期望 Carmichael 函数用于指数的模数。同样，美国国家标准技术研究所 (NIST) 的 FIPS 186-4（数字签名标准）要求 \\(d\\) 小于 \\(λ(n)\\)。

在那些严格的背景下，任何 \\(d\\) 大于 \\(λ(n)\\) 的 RSA 密钥都被认为不合规。这实际上迫使实现使用基于 \\(λ(n)\\) 的较小指数，因为任何“超大” \\(d\\) 都可以简化为 \\(mod ~~λ(n)\\) 以满足标准。

诸如 FIPS 186-4 \[1\]（数字签名标准）和 RFC 8017 \[2\]（规定 RSA 加密的 PKCS#1 v2.2）的标准包含要求或建议，暗示私有指数 \\(d\\) 应尽可能小，理想情况下小于 \\( \\lambda(n)\\)。直接使用最小公倍数 \\(p-1\\) 和 \\(q-1\\) 来计算 \\(\\lambda(n)\\) 会生成最小的有效 \\(d\\)，而使用 \\(\\varphi(n)\\) 通常导致 \\(d\\) 比必要的要大。这不仅提高了性能（通过减少解密/签名过程中所需的模乘次数），还帮助保持协议间的互操作性，这些协议期望 \\(d\\) 小于某个特定大小。

Python 的加密库（PyCA cryptography）明确记录\[5\]指出，其使用 Carmichael 的充分函数来生成“最小的有效 \\(d\\) 值”，并指出旧实现（包括原始的 RSA 论文）使用欧拉函数得到了更大的指数。OpenSSL 也在其低级 RSA API 中使用了 Carmichael 函数 \[6\]。

以下是翻译后的内容：

## 原始 RSA 的问题

当发现两个主要的弱点时，原始或“教科书”RSA 很快被发现是不安全的。

RSA 所涉及的操作完全是确定性的，这意味着对于给定的明文 \\(m\\)，加密总会产生相同的密文 \\(C = m^e \\mod n\\)。

窃听者或攻击者，例如 Eve，可以通过利用输出的可预测性来猜测或推导明文。由于 RSA 加密是一个公开操作，攻击者可以加密可能的消息并将结果与目标密文进行比较——一种简单的选择明文_攻击_。

除此之外，教科书 RSA 也是可塑的。这意味着它的代数结构允许攻击者以有意义的方式操作密文。例如，给定一个密文 \\(C = RSA(M)\\)，攻击者可以将其乘以已知值（假设为 r）的加密来生成新的密文 \\(C’ = C · r^e ~~mod ~n\\)，该密文解密为明文 \\(M·r\\)。当合法接收者解密 \\(C'\\) 时，结果是 \\(M·r\\)，攻击者可以从中常常恢复 \\(M\\)。

让我们通过一个小的实际例子来理解这些漏洞。

## 利用教科书 RSA 的确定性和可塑性

### **密钥生成（设置）**

在我们的玩具示例中，我们将选择小的素数并生成一个 RSA 密钥对：

选择 \\(p =3\\) 和 \\(q=11\\)。这两个值都是素数。现在，计算模数和欧拉函数：

$$\\begin{gather} \\begin{split} n = p × q = 3 × 11 = 33 \\\\ φ(n) = (p – 1) × (q – 1) = 2 × 10 = 20 \\end{split} \\end{gather}$$

现在选择公开指数。我们考虑 \\(e=3\\)，因为它与 \\( φ(n) = 20\\) 互质，且 \\(gcd(3, 20) = 1\\)。

现在计算私有指数。我们知道 d 是 \\(e ~~mod ~φ(n)\\) 的模逆。我们需要找到 d 使得 \\((d × e) ≡ 1~~ (mod ~20)\\)。根据这个知识我们可以计算 \\(d = 7\\)，因为 \\(3 × 7 = 21 ≡ 1 ~~ (mod~ 20)\\)。

最后，公开密钥是 \\((n = 33, ~ e = 3)\\)，私有密钥（秘密）是 \\(d = 7\\)。

### 加密过程

现在，让我们使用上述密钥加密一个简单的消息。选择明文为 \\(M = 4\\)。此时的密文为：

$$\\begin{gather} \\begin{split} C = 4^3 ~~mod ~33 \\\\ C = 64 ~~mod ~33 \\\\ C = 64 – 33×1 = 31 \\end{split} \\end{gather}$$

到目前为止的结论是，如果我们用公开密钥 \\((e=3, n=33)\\) 加密消息 \\(4\\)，将会产生密文 \\(31\\)。现在，让我们尝试这些利用手法。

### 确定性利用（密文猜测攻击）

教科书 RSA 是确定性的——相同的明文总是产生相同的密文（没有涉及随机性）。攻击者截获到密文 \\(C=31\\)，可以通过加密可能的明文猜测并比较结果来利用这一点：

假设攻击者 Eve 将尝试用公开密钥加密候选明文，并查看哪个产生 \\(31\\)。他们可能会选择随机值来提高效率：

$$\\begin{gather} \\begin{aligned} Guess~ M = 1 ⇒ 1^3~~ mod ~33 = 1 \\\\ Guess~ M = 2 ⇒ 2^3~~ mod ~33 = 8 \\\\ Guess~ M = 3 ⇒ 3^3~~ mod ~33 = 27 \\\\ Guess~ M = 4 ⇒ 4^3~~ mod ~33 = 31 \\\\ \\end{aligned} \\end{gather}$$

通过简单地比较密文，攻击者发现加密 \\(4\\) 得到 31，与截获的密文相吻合。因此，攻击者了解到原始明文 \\(M\\) 是 \\(4\\)。这是可能的，因为教科书 RSA 中没有随机化——窃听者可以通过尝试加密猜测来识别消息，如果消息空间较小或可猜测，则可能破坏保密性。

### 可塑性利用（密文操控攻击）

原始 RSA 也是可塑的。这意味着攻击者可以获取密文并以某种方式修改它，使得解密后的明文发生可预测的变化。让我们了解这是如何工作的。

RSA 具有乘法属性，即两个密文相乘相当于在加密前相乘它们的明文：

$$E(M\_1) \\cdot E(M\_2) \\mod n = (M\_1^e \\mod n)\\times(M\_2^e \\mod n) \\mod n = (M\_1 \\cdot M\_2)^e \\mod n$$

下面的序列图解释了在天真的 RSA 中可塑性利用是如何工作的。

![Sequence Diagram: Malleability Exploit](https://cdn.hashnode.com/res/hashnode/image/upload/v1741314973046/6be306c5-3ca6-4ea8-8daf-d1937b6459df.png)

Alice 在初始化阶段后将密文发送给 Bob。注意到此时，n 和 e 是公知的。Eve 使用诸如 MiTM（中间人）攻击等机制截获此密文。

现在，Eve 选择一个已知值来操控消息。假设攻击者选择 \\(X = 2\\)（意图将原始明文加倍）。

然后他们使用公钥计算 X 的加密：

$$E(X) = 2^3 \\mod 33 = 8.$$

现在，Eve 将原始密文乘以该值（mod n）来得到新的密文：

$$\\begin{gather} \\begin{split} C{\\prime} = C \\times E(X) \\mod n = 31 \\times 8 \\mod 33 \\\\ C{\\prime} = 248~~ mod~ 33 = 248 – 33×7 = 248 – 231 = 17 \\end{split} \\end{gather}$$

在现实世界中的选择密文攻击中，攻击者可能会访问解密预言机或观察系统响应以揭示关于 \\(M{\\prime}\\) 的信息。解密结果 \\(8\\) 正好是 \\(M \\times 2\\)（原始消息乘以攻击者选定的因子）。知道因子 \\(X = 2\\)，攻击者可以通过除法来推断原始消息：\\(8/ 2 = 4\\)。

请注意，Eve 并没有在此处破解 RSA 的数学基础。他们只是使用公钥计算了 \\(2\\) 的加密，然后将其与截获的密文结合起来。他们尚不知道原始明文，但他们以一种方式操纵了密文，使他们知道新明文是原始消息的两倍。

## 低指数攻击

除了确定性和可塑性漏洞之外，传统的 RSA 也容易受到低指数攻击。使用小的公指数如 \\(e = 3\\)（有时是 \\(17\\)）非常流行，因为这可以加快加密和签名验证速度。但是，这很快就成了安全隐患。

当 RSA 使用小的公指数（例如 \\(e = 3\\)）且明文非常短（使得 \\(M^3\\) 小于模数 \\(n\\)）时，加密不会模 \\(n\\) “环绕”。在数学上：

$$c = M^3 \\mod n = M^3 \\quad \\text{(当 \\( M^3 < n \\) 时)}$$

让我们通过一个简单的例子来理解这一点：

假设我们的明文是： \\(M = 5\\)。我们计算 \\(M^3\\) 为 \\(M^3 = 5^3 = 125\\)。

现在假设 \\(n\\) 是一个 \\(4096\\) 位的数字，相比于 \\125\\ 这个值很大。在这种情况下，密文只是 \\(c = 125\\)。Eve 截获到 \\(c = 125\\) 可以计算 \\125\\ 的立方根以获得明文：\\(\\sqrt\[3\]{125} = 5\\)，从而直接恢复 \\(M\\)。

这表明如果 \\(M\\) 足够小，当 \\(e\\) 较低时密文会泄露明文。

## Håstad 的广播攻击：低指数遇上多个接收者

1985 年，Johan Håstad 阐明了广播攻击，展示了当低指数 \\(e\\) 在相同消息被广播到多个方时的危险性。

假设 Alice 想要将相同的明文消息 M 发送给三个不同的接收者。每个接收者都有各自的 RSA 公钥，其模数为 \\(N\_1, N\_2, N\_3,\\)，但为了加速他们都使用 \\(e = 3\\)（这是过去常见的做法）。Alice 使用每个公钥加密 \\(M\\)，得出密文：

$$\\begin{gather} \\begin{split} C\_1 = M^3 \\bmod N\_1 \\\\ C\_2 = M^3 \\bmod N\_2 \\\\ C\_3 = M^3 \\bmod N\_3 \\end{split} \\end{gather}$$

Eve 拦截所有三个 \\(C\_1, C\_2, C\_3\\) 可以在不破解任何单一 RSA 密钥的情况下恢复 M。

由于每个 \\(N\_i \\) 是不同的（我们假设它们是两两互质的，如 RSA 密钥应当是），攻击者可以使用中国剩余定理（CRT）结合 三个同余 \\(x \\equiv C\_i \\pmod{N\_i}\\)。注意此时 Eve 只有 \\(C\_1\\)，\\(C\_2\\) 和 \\(C\_3\\)。她没有明文 \\(M\\) 或 \\(M^3\\)，但她可以用截获的数据重构 \\(M^3\\)。要理解中国剩余定理和这种重构，您可以参见这篇：[CRT, RSA, and Low Exponent Attacks | Youtube][40]。

对于 \\(x\\)，存在模 \\(N\_1N\_2N\_3\\) 的唯一解，该解实际上是一个整数，\\(x = M^3\\) （因为真正的整数 \\(M^3\\) 小于每个 \\(M < N\_i \\) 的乘积 \\(N\_1N\_2N\_3\\)）。本质上，CRT 让 Eve 能够准确地重构 \\(M^3\\)。一旦他们拥有了作为普通整数的 \\(M^3\\)，他们只需取立方根即可找到 \\(M\\)。不需要分解任何模数或逆转 RSA 函数——数学由于低指数的原因自然而然地解决了。

下面的序列图旨在提供对攻击的高级理解：

![序列图：Håstad 的广播攻击](https://mermaid.ink/img/pako:eNqNlN9P2zAQx_-VmyWkIpWqSeostTQkFvawh-6h7AFNEcgk19RSY3e2A3RV__dd-gNoExB5is_f-_jum3PWLDcFMsEc_q1R53itZGlllWmgZymtV7laSu3haqFyhN4N6gLteXv_u3mA3hRppZCWQYckldYs3orCDtG1fMS3mqhD86ORXBWPaJ20KxLsJL-MRzAUPSlW7NdPlOvAG3AUhwqdkyXCpIn4uUUEezjVDQ7MYxJcXF62OxXQbDugyBytx2cPvfQ-gG8wuYugMgXo-4MfHbwOW7qJ4RExfJ_Y9rAbGB0Boxcjz862Fivt0ea4JNP2ZjnoFcZ7LEBaa57cvoST7wEX79j08xVI_nyQ22nJUXb4QXZX-0fJUXtiTkACKN1o522dU0rvdufUOdRO6RLS6e8DolUBFdCCpaZa1p7sS-sHhKkxHswMbj9RRhOgsWw2aXTnJLOqVFouXuf3S6ZZn1VoK6kKusrrBpoxEleYMUGvBc5kvfAZy_SGpLL25malcyaoPeyzellIf7j5TMzkwlGUbhoTa_bMRMCHAx7xMU84j5I4HPfZiolRMhgNR-NkxOM45FE8ijd99s8YIgwH4zCMEp4EQTLkX0MebHF_tpu7M7FQ3tjJ7uez_Qf1mTV1OX85v7RNNzu13Q53amrtmUjGm_8gLoH2?type=png)

现在让我们以一个示例来看这种攻击：

假设三个不同的 RSA 公钥都使用 \\(e=3\\) 指数，通过模数 \\( n\_b = 187\\)（为 Bob）， 
\\(n\_c = 115 \\)（为 Carol），和 \\(n\_d = 87\\)（为 Dave）。

这些 \\(n\_i\\) 是两两互质的（每对的 \\(gcd\\) 为 \\(1\\)）。现在假设相同的明文消息 \\(M\\) 被用每个公钥加密。让我们取一个具体的 \\(M\\)。例如，\\(M=42\\)，我们将得到：

$$\\begin{gather} \\begin{split} c\_b = M^3 \\bmod n\_b \\\\ c\_c = M^3 \\bmod n\_c \\\\ c\_d = M^3 \\bmod n\_d \\\\ \\end{split} \\end{gather}$$

$$\\begin{gather} \\begin{split} c\_b = 42^3 \\bmod 187 = 36 \\\\ c\_c = 42^3 \\bmod 115 = 28 \\\\ c\_d = 42^3 \\bmod 87 = 51 \\\\ \\end{split} \\end{gather}$$

因此，观察到的三个密文分别是 \\(36\\), \\(28\\), 和 \\(51\\)。Eve 知道 \\(n\_b, n\_c, n\_d\\) 和这些密文，现在可以如下恢复 \\(M\\)：

1.  Eve 将计算总模数 \\(N = n\_b \\cdot n\_c \\cdot n\_d = 187 \\times 115 \\times 87 = 1,870,935.\\) （这是方程组的总模数）。
    
2.  现在 Eve 将为每个方程计算部分乘积：
    

$$\\begin{gather} \\begin{split} N\_b = \\frac{N}{n\_b} = \\frac{1,870,935}{187} = 10,005 \\\\ N\_c = \\frac{N}{n\_c} = \\frac{1,870,935}{115} = 16,269 \\\\ N\_d = \\frac{N}{n\_d} = \\frac{1,870,935}{87} = 21,505 \\end{split} \\end{gather}$$

3.  此时，Eve 需要每个 \\(N\_i\\) 在对应 \\(n\_i\\) 下的逆元：
    
    -   首先，Eve 计算 \\(M\_b = (N\_b)^{-1} \\bmod n\_b\\)，即一个数 \\(M\_b\\)，使得 \\(N\_b \\cdot M\_b \\equiv 1 \\pmod{187}\\)。在此情况下，\\(N\_b = 10005\\)。使用扩展欧几里得算法，Eve 可以找到 \\(M\_b = 2\\) (因为 \\(10005 \\times 2 = 20010 \\equiv 1 \\pmod{187}\\))。
        
    -   然后，Eve 计算 \\(M\_c = (N\_c)^{-1} \\bmod n\_c\\)。此时 \\(N\_c = 16269\\)。模 \\(115\\) 的逆元是 \\(M\_c = 49\\) (验证方法：\\(16269 \\times 49 \\equiv 1 \\pmod{115}\\))。
        
    -   接下来，Eve 计算 \\(M\_d = (N\_d)^{-1} \\bmod n\_d\\)。对于 \\(N\_d = 21505\\)，模 \\(87\\) 的逆元也是 \\(M\_d = 49\\) (巧合的是，在这种情况下相同，因为 \\(21505 \\times 49 \\equiv 1 \\pmod{87}\\))。
        

现在，Eve 使用中国剩余定理重建结合值，针对三个方程组的同余。构建此公式超出本手册的范围，但要完全了解其如何生效，您可以观看此视频：[CRT, RSA and Low Exponent Attacts | YouTube][41]。

$$C \\;=\\; c\_b \\cdot N\_b \\cdot M\_b \\;+\\; c\_c \\cdot N\_c \\cdot M\_c \\;+\\; c\_d \\cdot N\_d \\cdot M\_d \\pmod{N}$$

替换数字：

$$C = 36 \\cdot 10005 \\cdot 2 \\;+\\; 28 \\cdot 16269 \\cdot 49 \\;+\\; 51 \\cdot 21505 \\cdot 49 \\pmod{1,870,935}$$

让我们仔细计算每个项：

$$\\begin{gather} \\begin{split} 36 \\cdot 10005 \\cdot 2 = 720,360 \\\\ 28 \\cdot 16269 \\cdot 49 = 22,341,348 \\\\ 51 \\cdot 21505 \\cdot 49 = 5,37,40,995 \\\\ \\end{split} \\end{gather}$$

将这些加在一起得到一个总值 \\(7,20,360 + 2,23,41,348 + 5,37,40,995 = 7,67,82,423\\)。现在，取模 \\(N = 1,870,935\\)：

$$\\begin{align} \\begin{split} C \\equiv 7,67,82,423 \\pmod{1,870,935}\\\\ C = 74,088 \\\\ \\end{split} \\end{align}$$

现在，Eve 将简单地取 \\(C\\) 的立方根：\\(\\sqrt\[3\]{74088} = 42\\)，这就是原始明文。  
Eve 成功恢复了 \\(M\\)。

这些攻击的关键教训是没有适当的防护措施。RSA 本身并不满足现代安全性的定义。它不抗选择明文或选择密文本攻击。理论上的单向函数（RSA 的陷门置换）与安全加密方案之间的差距在实施者发现简单 RSA 可以被各种聪明的技巧“破解”时变得显而易见。

为了弥补这些弱点，标准组织引入了填充方案来增强 RSA 加密。在接下来的部分中，您将学习关于这些填充方案及其如何被利用的内容。

## RSA 填充方案介绍

在我们深入讨论填充方案及其对我们的案例有何帮助之前，让我们快速回顾一下使用填充的必要性。

教科书中的 RSA 加密是确定性的。在给定公钥下，相同的明文总是产生相同的密文。这种确定性使得原始 RSA 不安全。攻击者可以猜测可能的信息，用公钥加密它们，并与目标密文比较，以查看哪个猜测匹配。

除了确定性之外，小指数攻击说明了为何填充至关重要。如果消息 \\(m\\) 相对于模数太小，将其提升到较小的公开号（如 \\(e=3\\)）可能不会在 \\(N\\) 上绕行。用随机数据填充明文后再加密可以通过使密文不可预测并确保 \\(m^e\\) 跨越模数的范围，来解决这些问题。

## **公钥密码学标准 (PKCS#1 v1.5)**

1998 年，Kaliski 和 RSA 实验室在一份公开发布的文档中向世界介绍了 PKCS#1 v1.5 \[7\]。在 PKCS#1 v1.5 中，每个 RSA 加密消息都被包装在一个特殊的“加密块” \\(EB\\) 中。此块确保原始消息的大小适合 RSA，并以难以篡改的方式填充。

在这个方案中，明文被填充为模数 \\(N\\) 的大小（字节）：

$$EB = 00 ~||~ BT ~||~ PS ~||~ 00 ~||~ M$$

这里，\\(0x00\\)（前导零字节）始终在前面。它确保当连接的字符串 \\(EB\\) 转换为大端整数时，值小于 RSA 模数（即，我们不会得到一个对 RSA 来说太大的数）。当我们深入研究背后的数学时，您会更加欣赏这一事实。

接下来的一段是填充字符串 \\(PS\\)。这是一个由非零随机字节组成的字符串。这对安全性至关重要，因为它在每次加密中引入了随机性。如果同一消息被多次加密，这些随机字节可以确保每个密文看起来不同，从而阻止许多依赖于检测重复模式的简单攻击。

接下来的一个字节 \\(0x00\\) 是一个**分隔符**。这个单一的零字节标志着填充的结束。在解密过程中，这有助于接收方快速识别填充结束和实际消息开始的位置。

最后，我们有您想要保护的实际数据——\\(M\\)。一旦接收方验证了填充，他们就确切知道在哪里可以找到这条消息。

这种机制帮助解决了天真 RSA 的确定性问题。在接下来的部分中，让我们了解 PKCS#1 v1.5 填充中涉及的数学及其安全影响。

### PKCS#1 v1.5 背后的数学

在开始之前，让我们正确使用符号和缩写。我们将使用大写符号（例如 \\(EB\\)）来表示八位字节字符串和位字符串。我们将使用小写符号（例如 \\(n\\)）来表示整数。

在 PKCS#1 v1.5 中，我们将使用 \\(k\\) 来表示 RSA 模数 \\(n\\) 的长度，单位为字节。例如，如果您有一个\\(1024\\)位的 RSA 密钥，则 RSA 模数 \\(n\\) 是一个 \\(1024\\)位的数字。由于一个字节有 \\(8\\)位，如果您的 RSA 模数是 \\(L\\)位长，那么：

$$k = \\left\\lceil \\frac{L}{8} \\right\\rceil = \\frac{1024}{8} = 128 \\text{ bytes}$$

加密块的总长度将等于此 RSA 密钥长度 \\(k\\)（以字节为单位）。在这里，数据 \\(M\\) 的长度不得超过 \\(k-11\\) 个八位字节，因为 \\(11\\) 个字节用于块 – \\(0x00 ~||~ 0x02 ~||~ PS ~||~ 0x00\\)。这种限制保证了填充字符串 \\(PS\\) 的长度至少为八个八位字节，这是 PKCS#1v1.5 中的一个安全条件：

$$∣PS∣=k~−∣M∣−~3$$

例如，对于 \\(1024\\)位的 RSA 模数，\\(k\\) 的值为 \\(128\\)。此时爱丽丝可以加密最多 \\(128 - 11 = 117\\) 字节的数据。\\(11\\) 个字节用于 \\(0x00 ~||~ 0x02 ~||~ PS ~||~ 0x00\\) 结构。随机的 \\(PS\\) 确保对同一消息的每次加密都会产生不同的密文，从而防止确定性加密问题。

RSA 不直接对字节进行操作。一旦填充后的字符串 \\(EB\\) 准备好，就需要按照八位字节字符串到整数基本公式（OS2IP）将其转换为整数：

$$x = \\sum\_{i=1}^{k} 2^{8(k - i)} \\,\\mathrm{EB}\_i$$

其中 \\(EB\_i\\) 是从头到尾的 \\(EB\\) 的八位字节。换句话说，\\(EB\_1\\)（第一个字节）是最高有效字节，\\(EB\_k\\)（最后一个字节）是最低有效字节。现在，爱丽丝可以简单地使用 \\(C = x^c \\mod n\\) 加密此块。

为巩固我们到目前为止的学习，让我们将其应用于一个示例明文并寻找填充块。

假设 RSA 模数是 \\(8\\) 字节长（\\(k=8\\)）。假设我们要加密一个 \\(2\\) 字节长的消息 \\(M\\)。然后，填充字符串 \\(PS\\) 必须填充剩余空间：

$$Total ~ bytes=k=8=1(0x00)+1(BT)+∣PS∣+1(delimiter)+∣M∣$$

由于 \\(∣M∣=2\\) 并且存在 \\(∣M∣=2∣\\) 个固定字节，可以找到填充字符串所需的长度：

$$∣PS∣=8−3−2=3 ~ bytes$$

让我们选择 \\(PS\\) 的 3 个任意非零字节，例如 - \\(0xA3, ~0x5F, ~0xC2\\)。假设消息为 ASCII 文本“Hi”。在十六进制中，表示为：'H' 的 \\(0x48\\) 和 'i' 的 \\(0x69\\)。

因此，完整的加密块为：

![PKCS#1 v1.5 中的示例加密块](https://cdn.hashnode.com/res/hashnode/image/upload/v1742368983011/f682532c-6664-4197-8e77-60ea034f82c5.png)

现在我们将使用之前讨论的 OS2IP 公式将此八位字节字符串转换为整数：

$$x = \\sum\_{i=1}^{k} 2^{8(k - i)} \\,\\mathrm{EB}\_i$$

对于我们的示例，使用 \\(k=8\\) 的转换是：

$$x=  0x00×256^7+0x02×256^6+0xA3×256^5+0x5F×256^4+0xC2×256^3+0x00×256^2+0x48×256^1+0x69×256^0$$

注意，可以根据需要将十六进制值转换为十进制。例如，\\(0xA3 = 163, 0x5F = 95, 0xC2 = 194, 0x48 = 72,\\) 和 \\(0x69 = 105\\)。

在应用该公式时，有一个有趣的观察。由于前两个字节是固定的（\\(0x00\\) 和 \\(0x02\\)），整数 \\(x\\) 具有已知的下限。前两个字节的贡献是：

$$0×256^ 7 +2×256^ 6 =2×256^ 6$$

其余字节（\\(PS\\)、分隔符和 \\(M\\)）增加了一些值，该值至少为 \\(0\\) 并且最大不到 \\(256^6\\)（因为第二个字节固定为 \\(0x02\\) 而不能为 \\(0x03\\)）。因此，\\(x\\) 的范围是：

$$2×256 ^ 6 ≤x<3×256 ^ 6$$

这种使范围可预测的特性为 Bleichenbacher 攻击（也称为“填充 oracle”攻击）铺平了道路。如果一个系统显示解密块是否“填充正确”，攻击者可以系统地探测不同的密文并缩小明文的范围，因为攻击者知道它必须在该窄范围内。让我们在接下来的部分中详细了解 Bleichenbacher 攻击，并了解该攻击的工作原理。

在1998年，Daniel Bleichenbacher发表了一篇开创性的论文\[8\]，展示了一种针对使用PKCS#1 v1.5填充的RSA的自适应选择密文攻击。Bleichenbacher攻击，也被称为“百万消息”攻击，展示了如果攻击者可以访问一个能够告知提交的密文是否解密为正确填充的明文的oracle（即，PKCS#1 v1.5格式是否正确），攻击者可以逐渐恢复完整的明文。让我们来分解这个攻击是如何运作的：

首先，Eve需要一个Oracle。攻击假设攻击者可以查询一个系统，比如一个SSL/TLS服务器，并找出给定的密文\\(C\\)是否符合PKCS#1 v1.5。在1998年的论文中，Bleichenbacher利用了这样一个事实：当一个TLS服务器被提供一个填充不正确的RSA加密预主密钥时，如果填充错误，它会以一个特定的错误警报响应。本质上来说，服务器充当了一个oracle：它会用其私钥解密\\(C\\)，然后简单地告诉攻击者“填充OK”或“填充错误”（错误可能是基于时间的或是明确的警报）。

注意，这个oracle并不会透露明文。它一次只会透露一个比特的信息：“填充合法与否。”这看似无害，但Bleichenbacher证明了这足以最终恢复明文。

快速回顾一下，攻击者的目标是使用oracle找到未知的消息整数\\(m\\)（作为整数的PKCS#1填充明文），给定其密文\\(C = m^e \\bmod N\\)。我们知道如果\\(m\\)是正确填充的，它处于一个特定的数字范围内：\\(2B \\le m < 3B\\) 这里\\(B = 2^{8\*(k-2)}\\)，如前所述。

如果\\(k=128\\)字节，那么\\(B=2^{8\*126}\\)，一个正确填充的\\(m\\)将以\\(0x00 ~||~0x02\\)开头，因此它在\\(2B\\)和\\(3B\\)之间。攻击者Eve最初只知道\\(m\\)在范围\\(\[2B, 3B)\\)内。

在Bleichenbacher攻击中，Eve将利用RSA的乘法属性。他们将选择一个数字\\(s\\)（称为乘数）并计算一个新的密文\\(C' = (C s^e) \\bmod N\\)。这里这\\(C'\\)对应一个新的明文：\\(m' = m s \\bmod N\\)（因为\\(C' \\equiv m^e \* s^e \\equiv (ms)^e \\pmod{N}\\)）。

为了开始攻击，Eve找到一个\\(s\_0\\)，使得\\(C\_0 = C \* (s\_0)^e \\mod N\\)生成一个有效填充。这被称为蒙蔽步骤。这通常很简单——例如，\\(s\_0\\)可以被选择为使\\(m \* s\_0\\)略高于\\(N\\)，这几乎肯定会环绕并落在\\(\[2B,3B)\\)中。攻击者不知道\\(m\\)可以直接验证这一点。他们依靠填充oracle的是/否响应来推断蒙蔽的明文\\((m×s\_0)\\mod  N\\)落在正确的范围内。

如果oracle返回“填充有效”对于给定的\\(s\_0\\)，它告诉攻击者\\(s\_0 \\mod N\\)落在\\(2B\\)和\\(3B\\)之间。从数学上说：

\[2B≤(m×s\_0)~mod  N<3B\]

现在，Eve将在一个循环中尝试缩小这个范围，这通常被称为区间缩减步骤。最初，Eve有一个宽广的区间\\(\[a, b\] = \[2B, 3B)\\)包含\\(m\\)。在每次迭代中，Eve尝试递增的\\(s\\)值（从某个最小值开始），直到oracle返回“填充OK”对于\\(C' = C\_0 \* s^e\\)。假设这一点发生在某个\\(s = s\_i\\)。根据这个反馈，Eve现在知道：

\[2B ≤  (m × s\_i) ~ mod N < 3B\]

这个同余意味着存在某个整数\\(r\\)，使得：

\[2B  ≤ (m×s\_i)−rN  <  3B\]

重组，我们对\\(m\\)得出约束：

\[\frac{2B+rN}{s\_i}  ≤  m  <  \frac{3B+rN}{s\_i}\]

Eve无法立即知道\\(r\\)，但他们可以通过考虑当前区间\\(\[a,b\]\\)对\\(m\\)来解出\\(r\\)的可能范围。本质上，Eve使用先前关于\\(m\\)的界限来猜测哪个\\(r\\)会使不等式成立，然后更新新的界限\\(\[a, b\]\\)为所有\\(m\\)可能解的交集。这会显著缩小区间。

每次oracle查询得到这样的约束。最终，区间\\(\[a,b\]\\)收缩到一个单一的值，\\(\[a,a\]\\)。此时，Eve可以使用以下方式找到明文：

\[m = (a × s\_i^{-1}) ~ mod N\]

那时，Eve已经恢复了整个填充明文\\(m\\)，通过去除填充，得到原始消息。

下面的序列图巩固了我们对攻击的学习：

![序列图：Bleichenbacher攻击](https://cdn.hashnode.com/res/hashnode/image/upload/v1742498318544/6e297215-ca3e-451d-9574-117c0f8a12cb.png)

Bleichenbacher攻击显示了PKCS#1 v1.5中的填充格式泄露了足够的信息，从而在不需要因式分解N的情况下实现了完整的私钥操作（解密消息）。这个攻击利用了可以构造密文，使其解密为一个看似有效的明文而不需知道明文的事实。本质上，PKCS#1 v1.5填充使得大约\\(1\\)在\\(2^{16}\\)（大致）机会中，随机数据块会显得“有效填充”。这足以让自适应攻击以可行的查询次数成功。

为了解决 Bleichenbacher 攻击而不立即更改填充方案，从业者实施了一些防御措施。例如，TLS 应该将所有解密失败的情况视为相同（这样攻击者就无法区分填充和其他错误），并且服务器在填充失败时会生成一个假预主密钥以继续握手并避免时间泄露。然而，最安全的做法还是弃用 PKCS#1 v1.5 加密，转而使用例如 RSA-OAEP 的方案。[​][42]

## 最佳非对称加密填充（OAEP）

到 1995 年底，Bellare 和 Rogaway 提出了最佳非对称加密填充（OAEP），目标是实现可证明的安全性。这个填充旨在使 RSA 加密不仅对被动攻击，而且对自适应选择密文攻击具有抗性。换句话说，即使攻击者可以诱使系统解密选择的密文（作为一个“oracle”），他们也不应从中学到关于明文的任何有用信息。随后，OAEP 在 PKCS#1 v2.0 中被标准化（在 1998 年作为 RFC 2437 发布）及后来的版本。

与 PKCS#1 v1.5 相比，OAEP 有一个更复杂的编码，使用哈希函数和遮罩生成函数（MGF）在 RSA 加密前彻底随机化明文，提供更强的保证。

OAEP 的设计可以看作是一个使用随机种子的两层类似 Feistel 的网络。它利用输入消息并以仅在具有正确种子的情况下可以逆转的方式对其进行随机化。该方案在随机 Oracle 模型中被证明具有明文感知性，这意味着对手不能在不知道相应明文的情况下捏造出一个有效的密文。如果攻击者试图伪造或篡改密文，他们几乎肯定会生成一个无效的填充，将被拒绝。这个特性直接抵御了填充 Oracle 攻击。

OAEP（与适当的哈希/MGF 一起使用）能在假设 RSA 难以反转并将哈希函数视为随机 Oracle 的情况下，在自适应选择密文攻击中提供语义安全性。与缺乏正式证明的 PKCS#1 v1.5 不同，OAEP 提供了一个证明草案，该草案显示破解 RSA-OAEP 与破解 RSA 本身一样困难。

在实际中，这意味着 OAEP 大大降低了任何填充 Oracle 攻击的风险：攻击者几乎无法轻易找到通过填充检查的密文，除非通过暴力破解，其成功概率为 \\(2^{-hLen\*8}\\)。例如，使用 SHA-1 的成功概率为 \\(2^{-160}\\)。

下图是 OAEP 编码方案的可视化表现：

![最佳非对称加密填充](https://cdn.hashnode.com/res/hashnode/image/upload/v1742663541136/1c418939-80f6-45ea-8667-cacdc5cdab2b.png)

接下来，让我们了解这些数学概念的含义和 RSA-OEAP 的工作原理。

### OAEP 背后的数学

最佳非对称加密填充需要一个哈希函数，用于我们将在本节讨论的两个操作。我们将在 OAEP 中选择 SHA-1 作为哈希函数，\\(hLen\\) 表示哈希函数输出的字节长度。稍后我们将证明，即使不是抗碰撞的，MD5 或 SHA-1 也是 OAEP 的安全选择。

在我们深入数学之前，先回顾一些符号并定义我们将使用的主要部分：

在 RSA 中，\\(N\\) 是模数，\\(k\\) 是 _bytes_ 为单位的 \\(N\\) 的大小。对于一个 \\(2048\\) 位的模数，\\(k=256\\) 字节。  
\\(M\\) 是要加密的消息或明文。这个明文必须足够短以适合填充块（最多 \\(k−2⋅hLen−2\\) 字节）。在我们的符号中，\\(Hash\\) 指的是输出长度为 \\(hLen\\) 的加密哈希函数（例如，SHA-1，SHA-256）。例如，若使用 SHA-1，\\(hLen=20\\) 字节。

我们还将使用一个与消息相关的可选字符串（通常为空）。这是标签 \\(L\\)。如果这个标签为空，它的哈希是一个固定值。（例如：空字符串的 SHA-1）。

标签 \\(L\\) 的哈希表示为 \\(lHash\\)，其中 \\(lHash=Hash(L)\\)。如前所述，如果 \\(L\\) 为空，那么 \\(lHash\\) 就是 \\(Hash('')\\)。这意味着在任何情况下 \\(lHash\\) 都将持有一个值。

我们还将使用一个遮罩生成函数，\\(MGF\\)，通常记为 \\(MGF1\\)。这个函数接受一个输入（种子或遮罩数据）并通过迭代底层哈希函数产生指定长度的输出。我们将写作 \\(MGF(input,length)\\) 来表示“从 \\(input\\) 生成一个长度为 \\(length\\) 字节的遮罩”。

现在你已经熟悉了所有必要的符号，我们可以开始编码步骤了。

#### 步骤 1: 构建数据块（DB）

我们将计算 \\(lHash=Hash(L)\\)。如果 \\(L\\) 为空，\\(lHash\\) 是一个常数（例如，空字符串的 SHA-1）。

形成填充字符串 \\(PS\\)，\\(PS\\) 的长度选为整个块 \\(DB\\) 的长度为 \\((k−hLen−1)\\) 字节。数值上，\\(PS\\) 有 \\((k−mLen−2⋅hLen−2)\\) 字节的 \\(0x00\\)，其中 \\(mLen\\) 是消息 \\(M\\) 的长度。

现在，我们简单地将这些块连接起来生成数据块（\\(DB\\)）的八位字节字符串：

在这个例子中，单字节 \\(0x01\\) 作为一个分隔符，标记零填充结束和实际消息 \\(M\\) 开始的位置。\\(DB\\) 最终为 \\((k−hLen−1)\\) 个字节。

#### 第 2 步：为数据块生成掩码

首先，我们选择一个长度为 \\(hLen\\) 字节的随机字符串称为 \\(seed\\)。例如，在使用 SHA-1 时，\\(hLen=20\\)，那么我们说种子由 \\(20\\) 个随机字节组成。

现在，我们使用掩码生成函数 \\(MGF\\) 对 \\(seed\\) 创建一个与 \\(DB\\) 长度相同的掩码：

$$dbMask=MGF(seed,k−hLen−1)$$

其目的是将种子的随机性传播到整个 \\(DB\\)。

#### 第 3 步：掩盖数据块

现在，我们将使用按位 \\(XOR\\) 操作组合 \\(DB\\) 和 \\(dbMask\\)：

$$maskedDB=DB \\oplus dbMask$$

此步骤利用随机种子“扰乱”了 \\(DB\\)。

#### 第 4 步：为种子生成掩码

接下来，我们将根据 \\(maskedDB\\) 生成种子本身的掩码：

$$seedMask=MGF(maskedDB,hLen)$$

这一步只是确保种子不会被清晰显示出来。

#### 第 5 步：掩盖种子

现在我们将使用 \\(XOR\\) 操作结合原始种子和新掩码：

$$maskedSeed=seed \\oplus seedMask$$

现在种子也被数据块“扰乱”。

#### 第 6 步：形成最终编码消息 (EM)

我们现在准备构建我们的最终块。只需将所有内容连接成一个 \\(k\\) 字节的字符串：

$$EM=0x00~∣∣~maskedSeed~∣∣~maskedDB$$

前导 \\(0x00\\) 字节确保当 \\(EM\\) 被解释为整数时，小于 RSA 模数 \\(N\\)。此时，\\(EM\\) 为长度为 \\(k\\) 的 OAEP 填充消息。

#### 第 7 步：将连接的字符串转换为整数

请记住我们之前关于 PKCS#1v1.5 的讨论，RSA 无法直接操作此字节的连接字符串。我们需要使用 OS2IP 公式将 \\(EM\\) 块转换为非负整数：

$$x = \\sum\_{i=1}^{k} 2^{8(k - i)} \\,\\mathrm{EB}\_i$$

#### 第 8 步：执行 RSA 加密

现在我们已将编码消息 (\\(EM\\)) 转换为整数 \\(x\\)，准备执行基于公式的 RSA：

$$C =x^e \\bmod N$$

其中 \\((e,N)\\) 是公钥。由此计算出的 \\(C\\) 就是我们使用 RSA-OAEP 生成的密文。

在解密时，过程是反向的：接收方使用其私钥 \\(d\\) 计算 \\(m = c^d \\bmod N\\)，恢复 \\(EM\\)，然后将其拆分为 \\(0x00\\)、\\(maskedSeed\\) 和 \\(maskedDB\\)，并使用相同的 \\(MGF\\) 和哈希函数逆向解开 \\(XOR\\)。最后，他们检查恢复的 \\(lHash'\\) 是否与预期的哈希匹配，并且块包含正确的结构​ (\\(...||0x01||...\\))。

如果任何检查失败，则填充无效。只有当所有检查通过时，消息 \\(M\\) 才会返回。结果是，无效的密文几乎总是会被检测和拒绝，而不会给攻击者提供任何有用的信息。

设计上，OAEP 有效地解决了填充 oracle 问题。随机猜测产生有效 OAEP 编码的机会微乎其微：大约是 \\(2^{-hLen\*8}\\)。事实上，Daniel Bleichenbacher（在破坏 PKCS#1 v1.5 之后）提倡使用这样的“明文感知”填充，使得伪造有效填充变得不可行。

## **为什么 SHA-1 或 MD5 在 RSA-OAEP 中是安全的**

在上面一节中，我们提到我们将使用 SHA-1 进行数学公式和示例。当您在 RSA-OAEP 的上下文中看到 SHA-1 或 MD5 时，不要因这些哈希函数被认为在抗碰撞方面已被破坏而惊慌。仔细观察前一节，哈希函数在其中的作用非常具体，不依赖其碰撞抗性。让我们逐项分解：

### **标签哈希**

哈希函数用于计算一个可选标签 \\(L\\)（通常为空）的固定长度哈希。

现在让我们看看为什么在这个上下文中是安全的。这个被称为 \\(lHash\\) 的哈希充当域分隔符。它的任务只是确保标签在解密期间正确地与密文关联。只要标签被明智地选择（即，不是由对手控制的部分构建），那么碰撞抗性在这里就不是关键。

### **掩码生成函数 (MGF1)**

哈希函数还在 \\(MGF1\\) 中用于创建伪随机掩码。这个掩码同样应用于数据块 \\(DB\\) 和编码过程中使用的随机种子。

在此上下文中，哈希函数被视为随机 oracle。任务是将种子的随机性传播到更大的数据块中。为此，类似长度扩展或碰撞抗性的属性不相关。重要的是输出看起来是随机的，甚至 SHA-1 或 MD5 能在这种受控的、固定输入情况下提供这样的输出。

## 加密库中的采用 (PKCS#1 v1.5 vs OAEP)

在 Bleichenbacher 攻击之后，标准和库迁移到 OAEP 或至少添加对其的支持，同时将 PKCS#1 v1.5 视为遗留选项。现代加密库和协议反映了这些经验教训。

```markdown
OpenSSL 不鼓励用户使用 PKCS#1 v1.5，因为它会泄漏信息，可能被用于发动 Bleichenbacher 填充攻击 \[10\]。文档明确提到，强烈建议在新的应用程序中使用 `RSA_PKCS1_OAEP_PADDING`。

Python 加密库（PyCA cryptography）也建议开发者在加密中使用 OAEP 而非 PKCS#1 v1.5 \[11\]。

在 Bleichenbacher 1998 年攻击之后，立即在所有地方替换 PKCS#1 v1.5 是不可行的。因此，协议设计者发布了对策。

例如，TLS 的应对方法是改变错误处理：服务器不会显式揭示填充失败。它将生成一个虚假的 premaster secret，并继续以防止时间线索的暴露，并始终在稍后阶段返回通用的握手失败，这使得攻击者更难分辨解密失败的原因。

这些对策降低了 oracle 的精准度，但在不同的实现中很难做到完美无缺。事实上，并不是所有人都做对了——当实现中在错误处理上出错时，Bleichenbacher 攻击以各种形式重新浮现。

在 2018 年，研究人员发现了 ROBOT 攻击（重返 Bleichenbacher Oracle 威胁）：几种 TLS 实现出现了微妙的漏洞，重现了一个填充 oracle，使得 19 年后的攻击成功。ROBOT 论文表明，即使有对策指南，由于一致处理错误的复杂性，受欢迎的产品中还是会出现错误。

这强调了修补不安全方案常常容易出错——设计上安全的方案（如 OAEP）是更优的选择。

由于这些临时的安全措施和不能在所有现有系统中突然移除的事实，PKCS#1 v1.5 继续存在。它通常被视为“遗留”或“为兼容性而维护”。共同的智慧很明确：尽可能使用 OAEP 进行 RSA 加密。

## 增强数字签名：向 PSS 过渡

既然你已经了解到 OAEP 如何通过减轻确定性填充中的漏洞来改造 RSA 加密，现在是时候关注 RSA 数字签名了——确保消息完整性和真实性的关键功能。

早期的 RSA 签名方案存在与原始加密类似的问题：其确定性特性使其容易伪造和重放攻击。这一漏洞为改进铺平了道路：概率签名方案（PSS）。

在深入探讨 PSS 本身之前，我们先快速了解一下早期 RSA 签名的痛点。

### 早期 RSA 签名方案的问题

传统的 RSA 签名是通过对消息摘要（通常进行少量格式化）简单应用 RSA 解密函数来生成的：

$$s=m^d \\bmod N$$

其中 \\(m\\) 是消息的哈希（或编码哈希）。这种方法是确定性的，这意味着每次对相同消息进行签名，都会产生相同的签名。这种确定性有两个主要缺点：

1.  #### 可预测性和重放
    
    由于给定消息的签名总是相同的，攻击者可以毫无顾忌地重放捕获的签名，或者如果他们能够推断签名方案中的模式，则可伪造签名。
    
2.  #### 伪造风险
    
    在确定性环境中，如果攻击者在签名中发现任何结构或数学关系，他们可能能够为新消息伪造出有效签名。在某些场景中，弱格式化可能使对手能够创建“签名变换”，生成有效签名而无需访问私钥。
    

这些问题表明，为了防止自适应伪造尝试并确保不可抵赖性，签名方案必须是概率性的。这意味着签名者不能否认一个签名，因为它绑定于仅在签名时已知的随机值。

### 概率签名方案（PSS）的诞生

在 1998 年底，Bellare 和 Rogaway 也提出了一种方案以克服确定性 RSA 签名的固有限制 \[12\]。核心思想是把随机性引入签名生成过程，以便即使在两次签同一条消息时，结果签名也不同。这种随机性来自一个盐值和一个精心设计的编码过程。结果是一个具有强大、可证明安全性保证的签名方法。

这种随机性防止攻击者利用签名过程中的模式。概率签名方案被设计为在随机 oracle 模型中可证明安全的，这意味着在某些假设下，伪造签名的难度相当于破解 RSA 本身 \[13\]。

下图是 PSS 编码方案的视觉表示：

![概率签名方案](https://cdn.hashnode.com/res/hashnode/image/upload/v1742669558156/8137f535-deb7-4437-887a-53cf7a412089.png)

接下来，让我们了解这些数学概念的含义以及 RSA-PSS 的运作。
```

在深入了解 RSA-PSS 的机制之前，先了解一下在接下来的步骤中会看到的符号和术语是很有帮助的。

在 RSA 中，\\(N\\) 是模数，一个由两个素数的乘积构成的大整数。\\(k\\) 是 \\(N\\) 的长度，单位为 _字节_。对于一个 \\(2048\\) 位的密钥，\\(k=256\\) 字节。

\\(M\\) 代表您要签名的消息数据或文档。在 RSA-PSS 中，通常会首先计算 \\(M\\) 的哈希。\\(Hash\\) 指的是一种加密哈希函数（例如 SHA-256），将数据映射到一个固定大小的输出。输出长度记为 \\(hLen\\)。对于 SHA-256，\\(hLen=32\\) 字节。

我们将使用一个盐值 \\(S\\)，这是一段固定长度的随机生成字符串（通常与 \\(hLen\\) 相同）。这种随机性确保每个签名都是唯一的，即使是同一信息。

\\(H\\) 或者 \\(mHash\\) 是消息 \\(M\\) 的哈希，而 \\(H'\\) 是一个包括 \\(M\\) 和盐值 \\(S\\) 的二次哈希。这出现在 PSS 编码步骤中。

掩码生成函数 \\(MGF\\) 是一个使用内部哈希产生任意长度伪随机输出的函数。在 PSS 中，它用来“掩盖”数据块的部分，使签名难以伪造。

一个固定字节 \\(0xbc\\)（以十六进制表示）被附加在编码消息的末尾，标记 PSS 结构的边界。这在解码过程中作为简单的完整性检查。成功编码后，我们会得到一个长度为 \\(emLen = \\left\\lceil{\\frac{emBits}{8}}\\right\\rceil\\) 的编码消息 \\(EM\\)，它是一个八位字节串。

现在您已经熟悉所有必要的符号说明，我们可以开始编码步骤了。

#### 步骤 1: 消息哈希和盐值生成

我们计算消息的哈希为 \\(H~(mHash)=Hash(M)\\)，其中 \\(M\\) 是我们的消息。我们还将创建一个随机的盐值 \\(S\\)（固定长度，比如使用 SHA-1 时为 20 个字节）。

#### 步骤 2: 用盐值编码哈希（PSS-Encode）

我们将通过垫补、哈希和盐值构建一个数据块 \\(DB\\)。垫补是一串 \\(0\\) 的序列，用来填充并确保长度固定。数学上表示为：

$$M' = (0x)~00 ~00 ~00 ~00 ~00 ~00 ~00 ~00 ~||~ mHash ~||~ salt$$

现在我们计算这个块的哈希为 \\(H' = Hash(M')\\)。我们将生成另一个八位字节串 \\(PS\\) 并将其与盐值和 \\(0x01\\) 作为分隔符连接起来：

$$DB = PS ~||~ 0x01 ~||~ salt$$

注意，DB 是一个长度为 \\(emLen - hLen - 1\\) 的八位字节串。您在上面的可视化表示中看到的掩码必须是这个长度。数学上表示为：

$$dbMask = MGF(H, emLen - hLen - 1)$$

然后我们将在 \\(DB\\) 块上应用这个掩码，使用 \\(XOR\\) 运算来产生我们的 \\(maskedDB\\)：

$$maskedDB = DB \\oplus dbMask$$

回想一下 \\(emLen\\) 是编码消息 \\(EM\\) 的预期长度，\\(hLen\\) 是哈希输出的长度。现在我们附加一个固定的尾部字段 \\(0xbc\\) 并以八位字节串的形式产生编码消息：

$$EM = maskedDB ~||~ H ~||~ 0xbc$$

这个编码过程保证了盐值和哈希以不可逆的伪随机方式混合在一起。盐值的随机性通过 \\(MGF\\) 被“传播”到数据块中，使得任何对手几乎不可能篡改签名。

#### 步骤 3: RSA 签名生成

一旦您有了编码消息 \\(EM\\)，可以使用 RSA 私钥生成 RSA 签名。首先，使用我们先前讨论过的 OS2IP 方法将八位字节串转换为整数表示。随后进行 RSA 私钥运算：

$$s=m^d \\bmod N$$

这里 \\(d\\) 是私钥指数，\\(N\\) 是 RSA 模数。

#### 步骤 4: 签名验证

在接收方，当任何接收者希望验证签名时，他们会反向执行此过程：

$$m′= s^e \\bmod N$$

并将 \\(m'\\) 转换回编码消息 \\(EM\\)。验证者然后提取组件 \\((MaskedDB, H′, trailer)\\) 并重新从消息和盐值计算 \\(H'\\)。验证者确认嵌入在 \\(EM\\) 中的哈希和盐值符合预期。如果一切都验证无误，则签名有效。

## **前路：评估 RSA 的长期可行性**

1994 年，Peter Shor 的算法 \[14\] 显示量子计算机可以在多项式时间内分解大整数，从而有效攻破 RSA 所倚赖的难题——分解 \\(N = p \\times q\\) 的困难。

尽管实验性的量子计算机已有所进展，但距离拥有足够数量稳定量子比特以破解实际大小的 RSA 密钥（2048 或 4096 位）仍有很大距离。

为应对大规模量子计算机的到来，加密社区正在积极研发和标准化被认为能抵御量子攻击的算法。这些方案包括基于格子的方案（例如 CRYSTALS-Kyber 和 NTRU）、基于编码的加密（例如 McEliece 加密系统）、基于哈希的签名（例如 XMSS）和多变量多项式加密系统。

需要注意的是，虽然 OAEP 和 PSS 提升了 RSA 抵御传统攻击的安全性，但它们无法保护 RSA 不受量子攻击的影响。在一个后量子时代，即便是最安全的经典填充也无法阻止量子计算机使用 Shor 算法破解 RSA。

```markdown
## 参考文献

\[1\] FIPS 186-5: [数字签名标准 (DSS)][43]

\[2\] RFC 8017 PKCS #1: [RSA 加密规范][44]

\[3\] [拉格朗日定理][45]

\[4\] Ronald L. Rivest, Robert D. Silverman: [RSA 需要强素数吗][46]?

\[5\] [pyca/cryptography][47]

\[6\] [OpenSSL Github][48]: `rsa_chk.c`

\[7\] RFC 2313: [PKCS #1: RSA 加密][49]

\[8 \] Daniel Bleichenbacher: [针对基于 RSA 加密标准 PKCS #1 的协议的选择密文攻击][50]

\[9\] RFC 8017: [PKCS #1 RSA 加密规范版本 2.2][51]

\[10\] RSA\_public\_encrypt: [警告][52]

\[11\] [pyca/PKCS1v1][53]

\[12\] [概率签名方案][54]

\[13\] RFC 8017: [RSASSA-PSS][55]

\[14\] [用于量子计算的算法][56]: 离散对数和因式分解

[1]: #heading-prerequisites
[2]: #heading-the-alice-bob-paradigm
[3]: #heading-the-birth-of-the-rsa-cryptosystem
[4]: #heading-prime-numbers-and-composite-moduli
[5]: #heading-the-euler-totient-function
[6]: #heading-computing-the-keys
[7]: #heading-rsa-operations
[8]: #heading-encryption
[9]: #heading-decryption
[10]: #heading-digital-signatures
[11]: #heading-issues-with-eulers-totient-function-in-rsa
[12]: #heading-the-carmichael-function
[13]: #heading-mathematical-implication-of-the-carmichael-function
[14]: #heading-the-carmichael-function-in-modern-implementations
[15]: #heading-issues-with-raw-rsa
[16]: #heading-exploiting-textbook-rsas-determinism-and-malleability
[17]: #heading-key-generation-setup
[18]: #heading-encryption-process
[19]: #heading-determinism-exploit-ciphertext-guessing-attack
[20]: #heading-malleability-exploit-ciphertext-manipulation-attack
[21]: #heading-low-exponent-attacks
[22]: #heading-hastads-broadcast-attack-low-exponent-meets-multiple-recipients
[23]: #heading-introduction-to-padding-schemes-in-rsa
[24]: #heading-public-key-cryptography-standards-pkcs1-v15
[25]: #heading-the-mathematics-behind-pkcs1-v15
[26]: #heading-the-bleichenbacher-attack
[27]: #heading-optimal-asymmetric-encryption-padding-oaep
[28]: #heading-the-mathematics-behind-oaep
[29]: #heading-why-sha-1-or-md5-are-safe-in-rsa-oaep
[30]: #heading-label-hashing
[31]: #heading-mask-generation-function-mgf1
[32]: #heading-adoption-in-cryptographic-libraries-pkcs1-v15-vs-oaep
[33]: #heading-enhancing-digital-signatures-the-transition-to-pss
[34]: #heading-problems-with-early-rsa-signature-schemes
[35]: #heading-birth-of-the-probabilistic-signature-scheme-pss
[36]: #heading-the-mathematics-behind-pss
[37]: #heading-the-road-ahead-assessing-rsas-long-term-viability
[38]: #heading-references
[39]: https://www.youtube.com/watch?v=Mt9v7-xBuaA
[40]: https://www.youtube.com/watch?v=Mt9v7-xBuaA
[41]: https://www.youtube.com/watch?v=Mt9v7-xBuaA
[42]: https://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf#:~:text=plaintext%20is%20PKCS%20conforming,chosen%20ciphertexts%3B%20thus%2C%20we%20show
[43]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf
[44]: https://www.rfc-editor.org/rfc/rfc8017.html
[45]: https://en.wikipedia.org/wiki/Lagrange%27s_theorem_\(number_theory\)
[46]: https://people.csail.mit.edu/rivest/pubs/pubs/RS01.version-1999-11-22.pdf
[47]: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/
[48]: https://github.com/openssl/openssl/blob/85cabd94958303859b1551364a609d4ff40b67a5/crypto/rsa/rsa_chk.c
[49]: https://www.rfc-editor.org/rfc/rfc2313.html
[50]: https://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf
[51]: https://www.rfc-editor.org/rfc/rfc8017#section-7.1
[52]: https://docs.openssl.org/3.5/man3/RSA_public_encrypt/#warnings
[53]: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/#cryptography.hazmat.primitives.asymmetric.padding.PKCS1v15
[54]: https://en.wikipedia.org/wiki/Probabilistic_signature_scheme
[55]: https://www.rfc-editor.org/rfc/rfc8017#section-8.1
[56]: https://ieeexplore.ieee.org/abstract/document/365700/
```

